-- Generated by Oracle SQL Developer Data Modeler 20.3.0.283.0710
--   at:        2021-01-08 20:26:04 EET
--   site:      Oracle Database 11g
--   type:      Oracle Database 11g



-- predefined type, no DDL - MDSYS.SDO_GEOMETRY

-- predefined type, no DDL - XMLTYPE

CREATE TABLE angajati (
    id_angajat    NUMBER(3) NOT NULL,
    nume_angajat  VARCHAR2(30) NOT NULL
)
LOGGING;

ALTER TABLE angajati
    ADD CONSTRAINT nume_angajat CHECK ( REGEXP_LIKE ( nume_angajat,
                                                      '^[a-zA-Z]+(([,. -][a-zA-Z ])?[a-zA-Z]*)*$' ) );

ALTER TABLE angajati ADD CONSTRAINT angajat_pk PRIMARY KEY ( id_angajat );

CREATE TABLE carduri (
    id_card         NUMBER(2) NOT NULL,
    nr_card         NUMBER(16) NOT NULL,
    cvv             NUMBER(3) NOT NULL,
    data_expirare   DATE NOT NULL,
    detinator_card  VARCHAR2(30),
    cod_client      NUMBER(8) NOT NULL
)
LOGGING;

ALTER TABLE carduri ADD CONSTRAINT carduri_pk PRIMARY KEY ( id_card );

CREATE TABLE clienti (
    cod_client  NUMBER(8) NOT NULL,
    nume        VARCHAR2(30) NOT NULL,
    cnp         CHAR(13) NOT NULL,
    telefon     CHAR(10) NOT NULL,
    email       VARCHAR2(30)
)
LOGGING;

ALTER TABLE clienti
    ADD CONSTRAINT nume_client CHECK ( REGEXP_LIKE ( nume,
                                                     '^[a-zA-Z]+(([,. -][a-zA-Z ])?[a-zA-Z]*)*$' ) );

ALTER TABLE clienti
    ADD CHECK ( length(to_char(telefon)) = 10
                AND substr(to_char(telefon), 1, 2) = '07' );

ALTER TABLE clienti
    ADD CONSTRAINT email_client CHECK ( REGEXP_LIKE ( email,
                                                      '[a-z0-9._%-]+@[a-z0-9._%-]+\.[a-z]{2,4}' ) );


ALTER TABLE clienti ADD CONSTRAINT clienti_pk PRIMARY KEY ( cod_client );

ALTER TABLE clienti ADD CONSTRAINT email_unique UNIQUE ( email );

ALTER TABLE clienti ADD CONSTRAINT cnp_unique UNIQUE ( cnp );


CREATE TABLE contoare (
    id_contor                   NUMBER(8) NOT NULL,
    index_real                  NUMBER(6),
    index_virtual               NUMBER(6),
    data_instalare              DATE,
    data_ultima_citire          DATE,
    index_actualizat_de_client  CHAR(1),
    cod_contract                NUMBER(9)
)
LOGGING;

ALTER TABLE contoare ADD CHECK ( index_real >= 0 );

ALTER TABLE contoare ADD CHECK ( index_virtual >= 0 );

CREATE UNIQUE INDEX contoare__idx ON
    contoare (
        cod_contract
    ASC )
        LOGGING;

ALTER TABLE contoare ADD CONSTRAINT contoare_pk PRIMARY KEY ( id_contor );

CREATE TABLE contoare_angajati (
    contoare_id_contor   NUMBER(8) NOT NULL,
    angajati_id_angajat  NUMBER(4) NOT NULL,
    data_citirii         DATE NOT NULL
)
LOGGING;

ALTER TABLE contoare_angajati
    ADD CONSTRAINT contoare_angajati_pk PRIMARY KEY ( contoare_id_contor,
                                                      angajati_id_angajat,
                                                      data_citirii );

CREATE TABLE contracte (
    cod_contract     NUMBER(9) NOT NULL,
    adresa_contract  VARCHAR2(70) NOT NULL,
    cod_postal       NUMBER(6) NOT NULL,
    cod_client       NUMBER(8),
    data_start       DATE NOT NULL,
    id_serviciu      NUMBER(2)
)
LOGGING;

ALTER TABLE contracte ADD CONSTRAINT contracte_pk PRIMARY KEY ( cod_contract );

CREATE TABLE conturi_admin (
    id_admin      NUMBER(2) NOT NULL,
    parola_admin  VARCHAR2(40) NOT NULL
)
LOGGING;

ALTER TABLE conturi_admin ADD CONSTRAINT conturi_admin_pk PRIMARY KEY ( id_admin );

CREATE TABLE conturi_angajati (
    angajati_id_angajat  NUMBER(4) NOT NULL,
    parola_angajat       VARCHAR2(40) NOT NULL
)
LOGGING;

ALTER TABLE conturi_angajati ADD CONSTRAINT conturi_angajati_pk PRIMARY KEY ( angajati_id_angajat );

CREATE TABLE conturi_bancare (
    id_cont       NUMBER(2) NOT NULL,
    nume_cont     VARCHAR2(30) NOT NULL,
    iban          VARCHAR2(24) NOT NULL,
    suma_curenta  FLOAT(9)
)
LOGGING;

ALTER TABLE conturi_bancare ADD CHECK ( suma_curenta > 0 );

ALTER TABLE conturi_bancare ADD CONSTRAINT conturi_bancare_pk PRIMARY KEY ( id_cont );

ALTER TABLE conturi_bancare ADD CONSTRAINT iban_uniquev1 UNIQUE ( iban );

ALTER TABLE conturi_bancare ADD CONSTRAINT nume_cont_uniquev1 UNIQUE ( nume_cont );

CREATE TABLE conturi_clienti (
    clienti_cod_client  NUMBER(8) NOT NULL,
    parola_client       VARCHAR2(40) NOT NULL
)
LOGGING;

ALTER TABLE conturi_clienti ADD CONSTRAINT conturi_clienti_pk PRIMARY KEY ( clienti_cod_client );

CREATE TABLE facturi (
    numar_factura  NUMBER(12) NOT NULL,
    index_vechi    NUMBER(6) NOT NULL,
    index_nou      NUMBER(6),
    data_factura   DATE NOT NULL,
    cod_contract   NUMBER(8) NOT NULL,
    tip_factura    VARCHAR2(15),
    suma_in_avans  NUMBER(9, 4)
)
LOGGING;

ALTER TABLE facturi ADD CHECK ( index_vechi >= 0 );

ALTER TABLE facturi ADD CHECK ( index_nou > 0 );

ALTER TABLE facturi
    ADD CHECK ( tip_factura IN ( 'CITIRE_ANGAJAT', 'CITIRE_CLIENT', 'ESTIMARE' ) );

ALTER TABLE facturi ADD CONSTRAINT facturi_pk PRIMARY KEY ( numar_factura );

CREATE TABLE plata_factura (
    id_plata       NVARCHAR2(10) NOT NULL,
    suma_plata     FLOAT(6) NOT NULL,
    data_plata     DATE NOT NULL,
    numar_factura  NUMBER(12),
    id_cont        NUMBER(2)
)
LOGGING;

ALTER TABLE plata_factura ADD CHECK ( suma_plata > 0 );

CREATE UNIQUE INDEX plata_factura__idx ON
    plata_factura (
        numar_factura
    ASC )
        LOGGING;

ALTER TABLE plata_factura ADD CONSTRAINT plata_factura_pk PRIMARY KEY ( id_plata );

CREATE TABLE tip_serviciu (
    id_serviciu        NUMBER(2) NOT NULL,
    nume_serviciu      VARCHAR2(10) NOT NULL,
    pret_per_kilowatt  FLOAT NOT NULL
)
LOGGING;

ALTER TABLE tip_serviciu ADD CONSTRAINT pret_per_kw CHECK ( pret_per_kilowatt > 0 );

ALTER TABLE tip_serviciu ADD CONSTRAINT tip_serviciu_pk PRIMARY KEY ( id_serviciu );

ALTER TABLE carduri
    ADD CONSTRAINT carduri_conturi_clienti_fk FOREIGN KEY ( cod_client )
        REFERENCES conturi_clienti ( clienti_cod_client )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE contoare_angajati
    ADD CONSTRAINT contoare_angajati_angajati_fk FOREIGN KEY ( angajati_id_angajat )
        REFERENCES angajati ( id_angajat )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE contoare_angajati
    ADD CONSTRAINT contoare_angajati_contoare_fk FOREIGN KEY ( contoare_id_contor )
        REFERENCES contoare ( id_contor )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE contracte
    ADD CONSTRAINT contracte_clienti_fk FOREIGN KEY ( cod_client )
        REFERENCES clienti ( cod_client )
            ON DELETE SET NULL
    NOT DEFERRABLE;

ALTER TABLE contoare
    ADD CONSTRAINT contracte_contoare_fk FOREIGN KEY ( cod_contract )
        REFERENCES contracte ( cod_contract )
            ON DELETE SET NULL
    NOT DEFERRABLE;

ALTER TABLE facturi
    ADD CONSTRAINT contracte_facturi_fk FOREIGN KEY ( cod_contract )
        REFERENCES contracte ( cod_contract )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE conturi_angajati
    ADD CONSTRAINT conturi_angajati_angajati_fk FOREIGN KEY ( angajati_id_angajat )
        REFERENCES angajati ( id_angajat )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE conturi_clienti
    ADD CONSTRAINT conturi_clienti_clienti_fk FOREIGN KEY ( clienti_cod_client )
        REFERENCES clienti ( cod_client )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE plata_factura
    ADD CONSTRAINT conturi_facturi_fk FOREIGN KEY ( id_cont )
        REFERENCES conturi_bancare ( id_cont )
            ON DELETE SET NULL
    NOT DEFERRABLE;

ALTER TABLE plata_factura
    ADD CONSTRAINT facturi_plata_facturi FOREIGN KEY ( numar_factura )
        REFERENCES facturi ( numar_factura )
            ON DELETE SET NULL
    NOT DEFERRABLE;

ALTER TABLE contracte
    ADD CONSTRAINT tip_serviciu_contract_fk FOREIGN KEY ( id_serviciu )
        REFERENCES tip_serviciu ( id_serviciu )
            ON DELETE SET NULL
    NOT DEFERRABLE;

CREATE OR REPLACE TRIGGER Trigger_data_instalare 
    BEFORE INSERT OR UPDATE OR DELETE ON Contoare 
    FOR EACH ROW 
BEGIN
	IF( :new.data_ultima_citire > SYSDATE )
	THEN
		RAISE_APPLICATION_ERROR( -20001,
		'Data invalida: ' || TO_CHAR( :new.data_ultima_citire, 'DD.MM.YYYY HH24:MI:SS' ) || ' trebuie sa fie mai mica decat data curenta.' );
	END IF;

	IF( :new.data_ultima_citire < :new.data_instalare )
	THEN
		RAISE_APPLICATION_ERROR( -20001,
		'Data invalida: ' || TO_CHAR( :new.data_ultima_citire, 'DD.MM.YYYY HH24:MI:SS' ) || ' trebuie sa fie mai mare decat data de instalare ' || TO_CHAR( :new.data_instalare, 'DD.MM.YYYY HH24:MI:SS' ) );
	END IF;
END; 
/

CREATE OR REPLACE TRIGGER Trigger_index_curent 
    BEFORE UPDATE ON Contoare 
    FOR EACH ROW 
BEGIN
	IF( :new.index_virtual < :old.index_virtual )
	THEN
		RAISE_APPLICATION_ERROR( -20001,
		'Indexul nou introdus trebuie sa fie mai mare decat indexul precedent!' );
	END IF;
END; 
/


CREATE SEQUENCE angajati_id_angajat_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER angajati_id_angajat_trg BEFORE
    INSERT ON angajati
    FOR EACH ROW
    WHEN ( new.id_angajat IS NULL )
BEGIN
    :new.id_angajat := angajati_id_angajat_seq.nextval;
END;
/

CREATE SEQUENCE carduri_id_card_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER carduri_id_card_trg BEFORE
    INSERT ON carduri
    FOR EACH ROW
    WHEN ( new.id_card IS NULL )
BEGIN
    :new.id_card := carduri_id_card_seq.nextval;
END;
/

CREATE SEQUENCE clienti_cod_client_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER clienti_cod_client_trg BEFORE
    INSERT ON clienti
    FOR EACH ROW
    WHEN ( new.cod_client IS NULL )
BEGIN
    :new.cod_client := clienti_cod_client_seq.nextval;
END;
/

CREATE SEQUENCE contoare_id_contor_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER contoare_id_contor_trg BEFORE
    INSERT ON contoare
    FOR EACH ROW
    WHEN ( new.id_contor IS NULL )
BEGIN
    :new.id_contor := contoare_id_contor_seq.nextval;
END;
/

CREATE SEQUENCE contoare_angajati_contoare_id_ START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER contoare_angajati_contoare_id_ BEFORE
    INSERT ON contoare_angajati
    FOR EACH ROW
    WHEN ( new.contoare_id_contor IS NULL )
BEGIN
    :new.contoare_id_contor := contoare_angajati_contoare_id_.nextval;
END;
/

CREATE SEQUENCE contracte_cod_contract_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER contracte_cod_contract_trg BEFORE
    INSERT ON contracte
    FOR EACH ROW
    WHEN ( new.cod_contract IS NULL )
BEGIN
    :new.cod_contract := contracte_cod_contract_seq.nextval;
END;
/

CREATE SEQUENCE conturi_bancare_id_cont_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER conturi_bancare_id_cont_trg BEFORE
    INSERT ON conturi_bancare
    FOR EACH ROW
    WHEN ( new.id_cont IS NULL )
BEGIN
    :new.id_cont := conturi_bancare_id_cont_seq.nextval;
END;
/

CREATE SEQUENCE facturi_numar_factura_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER facturi_numar_factura_trg BEFORE
    INSERT ON facturi
    FOR EACH ROW
    WHEN ( new.numar_factura IS NULL )
BEGIN
    :new.numar_factura := facturi_numar_factura_seq.nextval;
END;
/

CREATE SEQUENCE plata_factura_id_plata_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER plata_factura_id_plata_trg BEFORE
    INSERT ON plata_factura
    FOR EACH ROW
    WHEN ( new.id_plata IS NULL )
BEGIN
    :new.id_plata := plata_factura_id_plata_seq.nextval;
END;
/

CREATE SEQUENCE tip_serviciu_id_serviciu_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER tip_serviciu_id_serviciu_trg BEFORE
    INSERT ON tip_serviciu
    FOR EACH ROW
    WHEN ( new.id_serviciu IS NULL )
BEGIN
    :new.id_serviciu := tip_serviciu_id_serviciu_seq.nextval;
END;
/

--tranzactie implementata printr-o procedura pentru a actualiza ultima data in cand a fost citit un contor
create or replace NONEDITIONABLE PROCEDURE citire_contor(nr_angajat NUMBER, nr_contor NUMBER, valoare_index NUMBER)
IS
    PRAGMA
        AUTONOMOUS_TRANSACTION;
BEGIN
    UPDATE Contoare SET data_ultima_citire = SYSDATE,index_real = valoare_index,index_actualizat_de_client=0 WHERE id_contor=nr_contor;  
    INSERT INTO contoare_angajati (Contoare_id_contor, Angajati_id_angajat, data_citirii) VALUES (nr_contor,nr_angajat,SYSDATE);
    COMMIT;
END;
/
--tranzactie pentru a realiza plata unei facturi
create or replace NONEDITIONABLE PROCEDURE tranzactie_plata_factura(nr_factura NUMBER, nr_cont NUMBER, suma NUMBER)
IS
    PRAGMA
        AUTONOMOUS_TRANSACTION;
BEGIN
    DECLARE valid NUMBER; suma_ultima_factura NUMBER;
    BEGIN
        SELECT decode(count(*), 0, 0, 1) INTO valid FROM plata_factura where numar_factura = nr_factura;  
        SELECT (facturi.index_nou-facturi.index_vechi)*(SELECT pret_per_kilowatt FROM tip_serviciu WHERE contracte.id_serviciu=tip_serviciu.id_serviciu) + 
        0.19*(facturi.index_nou-facturi.index_vechi)*(SELECT pret_per_kilowatt FROM tip_serviciu WHERE contracte.id_serviciu=tip_serviciu.id_serviciu) - facturi.suma_in_avans INTO suma_ultima_factura FROM Facturi, Contracte WHERE contracte.cod_contract = facturi.cod_contract AND facturi.numar_factura=nr_factura;          
        IF valid = 0 AND suma >= suma_ultima_factura--daca factura nu a fost platita si daca suma pe care vreau sa o platesc este mai mare decat valoarea facturei, atunci o platesc
        THEN
            begin
                DBMS_OUTPUT.put_line('hai ca platim');
            end;
            INSERT INTO Plata_factura (suma_plata,data_plata,numar_factura,id_cont) VALUES (suma,SYSDATE,nr_factura,nr_cont);
             COMMIT;
            UPDATE Conturi_bancare SET suma_curenta = suma_curenta + suma WHERE id_cont=nr_cont; 
            COMMIT;
        ELSE
            begin
                DBMS_OUTPUT.put_line('hai ca nu platim');
            end;
            raise_application_error( -20001, 'Plata deja a fost efectuata sau suma este prea mica.' );
        END IF;
    END
    COMMIT;
    
EXCEPTION
    WHEN OTHERS THEN
        begin
            DBMS_OUTPUT.put_line(SUBSTR(SQLERRM, 1, 64));
        end;
END;
/

--tranzactie pentru a actualiza index-ul unui contor
create or replace NONEDITIONABLE PROCEDURE actualizare_contor_client(nr_contor NUMBER, valoare_index NUMBER)
IS
    PRAGMA
        AUTONOMOUS_TRANSACTION;
BEGIN
    SAVEPOINT sv;
    UPDATE Contoare SET data_ultima_citire = SYSDATE,index_virtual = valoare_index WHERE id_contor=nr_contor;  
    UPDATE Contoare SET index_actualizat_de_client = 1 WHERE id_contor=nr_contor;  
    COMMIT;
    
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK TO sv;
END;
/
            

--procedura pentru a genera facturi noi
create or replace NONEDITIONABLE PROCEDURE generare_facturi
IS
    PRAGMA
        AUTONOMOUS_TRANSACTION;
BEGIN
    SAVEPOINT sv; 
    DECLARE idx NUMBER; contor_citit_de_angajat NUMBER; contor_citit_de_client NUMBER; plata_avans NUMBER; pret_tip_serviciu NUMBER; suma_restanta NUMBER;
    BEGIN    
        FOR rec IN (SELECT cod_contract,id_serviciu FROM Contracte)
        LOOP
            FOR rec_fact IN (SELECT index_vechi,index_nou,numar_factura,suma_in_avans FROM Facturi WHERE facturi.cod_contract = rec.cod_contract AND 
            facturi.data_factura = (SELECT max(data_factura) FROM facturi WHERE facturi.cod_contract = rec.cod_contract))
            LOOP
                IF rec_fact.index_nou - rec_fact.index_vechi < 0
                THEN
                    SELECT pret_per_kilowatt INTO pret_tip_serviciu FROM tip_serviciu WHERE rec.id_serviciu=tip_serviciu.id_serviciu;
                    plata_avans := -((rec_fact.index_nou - rec_fact.index_vechi)*pret_tip_serviciu + (rec_fact.index_nou - rec_fact.index_vechi)*pret_tip_serviciu*0.19 + rec_fact.suma_in_avans);
                ELSE
                    SELECT pret_per_kilowatt INTO pret_tip_serviciu FROM tip_serviciu WHERE rec.id_serviciu=tip_serviciu.id_serviciu;
                    IF (rec_fact.index_nou - rec_fact.index_vechi)*pret_tip_serviciu + (rec_fact.index_nou - rec_fact.index_vechi)*pret_tip_serviciu*0.19 < rec_fact.suma_in_avans
                    THEN
                        plata_avans := rec_fact.suma_in_avans - ((rec_fact.index_nou - rec_fact.index_vechi)*pret_tip_serviciu + (rec_fact.index_nou - rec_fact.index_vechi)*pret_tip_serviciu*0.19);
                    ELSE
                        plata_avans := 0;
                    END IF;
                END IF;
                SELECT decode(count(*), 0, 0, 1) INTO contor_citit_de_angajat FROM  Contoare, contoare_angajati where Contoare.cod_contract = rec.cod_contract AND 
                Contoare.id_contor=contoare_angajati.contoare_id_contor AND MONTHS_BETWEEN(CURRENT_DATE,contoare_angajati.data_citirii) <= 1;--exista un contor pentru acest contract si s-a facut o citire de catre angajat
                IF contor_citit_de_angajat = 1 
                THEN
                     SELECT decode(count(*), 0, 0, 1) INTO idx FROM plata_factura where numar_factura = rec_fact.numar_factura;      
                        IF idx = 1
                        THEN
                            plata_avans := plata_avans + rec_fact.suma_in_avans;
                            INSERT INTO Facturi (index_vechi,index_nou,data_factura,cod_contract,tip_factura,suma_in_avans) VALUES 
                            (rec_fact.index_nou,(SELECT index_real FROM Contoare WHERE contoare.cod_contract=rec.cod_contract),SYSDATE,rec.cod_contract,'CITIRE_ANGAJAT',(SELECT suma_plata FROM plata_factura WHERE plata_factura.numar_factura = rec_fact.numar_factura) - 
                            (SELECT (facturi.index_nou-facturi.index_vechi)*(SELECT pret_per_kilowatt FROM tip_serviciu WHERE rec.id_serviciu=tip_serviciu.id_serviciu) + 
                            0.19*(facturi.index_nou-facturi.index_vechi)*(SELECT pret_per_kilowatt FROM tip_serviciu WHERE rec.id_serviciu=tip_serviciu.id_serviciu)  FROM Facturi 
                            WHERE facturi.numar_factura = rec_fact.numar_factura + plata_avans));
                        ELSE
                            INSERT INTO Facturi (index_vechi,index_nou,data_factura,cod_contract,tip_factura,suma_in_avans) VALUES 
                            (rec_fact.index_nou,(SELECT index_real FROM Contoare WHERE contoare.cod_contract=rec.cod_contract),SYSDATE,rec.cod_contract,'CITIRE_ANGAJAT',plata_avans);
                        END IF;
                ELSE
                    SELECT decode(count(*), 0, 0, 1) INTO contor_citit_de_client FROM Contoare where Contoare.cod_contract = rec.cod_contract AND index_actualizat_de_client = 1;      
                    IF contor_citit_de_client = 1
                    THEN
                        SELECT decode(count(*), 0, 0, 1) INTO idx FROM plata_factura where numar_factura = rec_fact.numar_factura; 
                        IF idx = 1
                        THEN
                             plata_avans := plata_avans + rec_fact.suma_in_avans;
                             INSERT INTO Facturi (index_vechi,index_nou,data_factura,cod_contract,tip_factura,suma_in_avans) VALUES 
                            (rec_fact.index_nou,(SELECT index_virtual FROM Contoare WHERE contoare.cod_contract=rec.cod_contract),SYSDATE,rec.cod_contract,'CITIRE_CLIENT',(SELECT suma_plata FROM plata_factura WHERE plata_factura.numar_factura = rec_fact.numar_factura) - (SELECT (facturi.index_nou-facturi.index_vechi)*(SELECT pret_per_kilowatt FROM tip_serviciu WHERE rec.id_serviciu=tip_serviciu.id_serviciu) + 
                            0.19*(facturi.index_nou-facturi.index_vechi)*(SELECT pret_per_kilowatt FROM tip_serviciu WHERE rec.id_serviciu=tip_serviciu.id_serviciu)  FROM Facturi 
                            WHERE facturi.numar_factura = rec_fact.numar_factura)+ plata_avans);
                        ELSE
                             INSERT INTO Facturi (index_vechi,index_nou,data_factura,cod_contract,tip_factura,suma_in_avans) VALUES 
                            (rec_fact.index_nou,(SELECT index_virtual FROM Contoare WHERE contoare.cod_contract=rec.cod_contract),SYSDATE,rec.cod_contract,'CITIRE_CLIENT', plata_avans);
                        END IF;
                        UPDATE Contoare SET index_actualizat_de_client = 0  WHERE Contoare.cod_contract=rec.cod_contract; 

                    ELSE    
                        SELECT decode(count(*), 0, 0, 1) INTO idx FROM plata_factura where numar_factura = rec_fact.numar_factura;      
                        IF idx = 1
                        THEN
                            plata_avans := plata_avans + rec_fact.suma_in_avans;
                            INSERT INTO Facturi (index_vechi,index_nou,data_factura,cod_contract,tip_factura,suma_in_avans) VALUES 
                            (rec_fact.index_nou,rec_fact.index_nou + 200,SYSDATE,rec.cod_contract,'ESTIMARE',(SELECT suma_plata FROM plata_factura WHERE plata_factura.numar_factura = rec_fact.numar_factura) - (SELECT (facturi.index_nou-facturi.index_vechi)*(SELECT pret_per_kilowatt FROM tip_serviciu WHERE rec.id_serviciu=tip_serviciu.id_serviciu) + 
                            0.19*(facturi.index_nou-facturi.index_vechi)*(SELECT pret_per_kilowatt FROM tip_serviciu WHERE rec.id_serviciu=tip_serviciu.id_serviciu)  FROM Facturi 
                            WHERE facturi.numar_factura = rec_fact.numar_factura)+ plata_avans);
                        ELSE
                            INSERT INTO Facturi (index_vechi,index_nou,data_factura,cod_contract,tip_factura,suma_in_avans) VALUES 
                            (rec_fact.index_nou,rec_fact.index_nou + 200,SYSDATE,rec.cod_contract,'ESTIMARE', plata_avans);
                        END IF;
                    END IF;
                 END IF;
            END LOOP;
        END LOOP;
    
        --aici se genereaza primele facturi din baza de date
        FOR rec_fact IN (SELECT co.cod_contract FROM contracte co LEFT JOIN facturi fa ON co.cod_contract = fa.cod_contract 
        WHERE fa.cod_contract IS NULL)
        LOOP
            INSERT INTO Facturi (index_vechi,index_nou,data_factura,cod_contract,tip_factura,suma_in_avans) VALUES (0,250,SYSDATE,rec_fact.cod_contract,'ESTIMARE',0);
        END LOOP;
    
    END;
    COMMIT;
    
EXCEPTION
    WHEN OTHERS THEN
        begin
            DBMS_OUTPUT.put_line(SUBSTR(SQLERRM, 1, 64));
        end;
        ROLLBACK TO sv;
END;
/


-- Oracle SQL Developer Data Modeler Summary Report: 
-- 
-- CREATE TABLE                            13
-- CREATE INDEX                             2
-- ALTER TABLE                             41
-- CREATE VIEW                              0
-- ALTER VIEW                               0
-- CREATE PACKAGE                           0
-- CREATE PACKAGE BODY                      0
-- CREATE PROCEDURE                         0
-- CREATE FUNCTION                          0
-- CREATE TRIGGER                          13
-- ALTER TRIGGER                            0
-- CREATE COLLECTION TYPE                   0
-- CREATE STRUCTURED TYPE                   0
-- CREATE STRUCTURED TYPE BODY              0
-- CREATE CLUSTER                           0
-- CREATE CONTEXT                           0
-- CREATE DATABASE                          0
-- CREATE DIMENSION                         0
-- CREATE DIRECTORY                         0
-- CREATE DISK GROUP                        0
-- CREATE ROLE                              0
-- CREATE ROLLBACK SEGMENT                  0
-- CREATE SEQUENCE                         10
-- CREATE MATERIALIZED VIEW                 0
-- CREATE MATERIALIZED VIEW LOG             0
-- CREATE SYNONYM                           0
-- CREATE TABLESPACE                        0
-- CREATE USER                              0
-- 
-- DROP TABLESPACE                          0
-- DROP DATABASE                            0
-- 
-- REDACTION POLICY                         0
-- 
-- ORDS DROP SCHEMA                         0
-- ORDS ENABLE SCHEMA                       0
-- ORDS ENABLE OBJECT                       0
-- 
-- ERRORS                                   0
-- WARNINGS                                 0
